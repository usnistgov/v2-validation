# reference.conf

report {

  # Detections classifications
  classification {
    error         = "Error"
    warning       = "Warning"
    alert         = "Alert"
    high-alert    = "High Alert"
    informational = "Informational"
    affirmative   = "Affirmative"
    note          = "Validation Notes"
    spec-error    = "Specification Error"
  }

  # Detections categories
  category {

    # Structure
    usage = "Usage"
    o-usage = "O-Usage"
    cardinality = "Cardinality"
    length = "Length"
    length-spec-error = "Length Spec Error"
    format = "Format"
    extra = "Extra"
    unexpected = "Unexpected"
    invalid = "Invalid Content"
    unescaped = "Unescaped Separator"
	unresolved-field = "Unresolved Field Model"
    constant-value = "Constant Value"
    constant-value-spec-error = "Constant Value Spec Error"
    dynamic-mapping-match = "Dynamic Mapping Match"

    # Contraints
    constraint-failure = "Constraint Failure"
    coconstraint-failure = "CoConstraint Failure"
    content-failure = "Content Failure"
    constraint-success = "Constraint Success"
    coconstraint-success = "CoConstraint Success"
    content-success = "Content Success"
    constraint-spec-error = "Constraint Spec Error"
    content-spec-error = "Content Spec Error"
    co-constraint = "Co-Constraint"
    co-constraint-spec-error = "Co-Constraint Spec Error"

    # Predicate
    predicate-failure = "Predicate Failure"
    predicate-success = "Predicate Success"
    predicate-spec-error = "Predicate Spec Error"
    predicate-usage-selection = "Predicate Usage Selection"

    # Slicing
    slicing-spec-error = "Slicing Spec Error"
    slicing = "Slicing"

    # Value Sets
	ubs	= "Undetermined Binding Strength"
    evs = "EVS"
    pvs = "PVS"
    rvs = "RVS"
    code-not-found = "Code Not Found"
    vs-not-found = "VS Not Found"
    empty-vs = "Empty VS"
    vs-error = "VS Error"
    vs-no-validation = "Excluded From Validation"
    coded-element = "Coded Element"
    coded-element-xor = "Coded Element"
    binding-location = "Binding Location"
    vs-spec-error = "Value Set Binding Spec Error"
    no-code-usage = "No Code Usage"
    dynamic-vs = "Dynamic Value Set"
    duplicate-code = "Duplicate Code"
    duplicate-code-codesytem = "Duplicate Code & Code System"
    vs-0396 = "ValueSet 0396"

    # Single Code
    single-code-failure = "Single Code Failure"
    single-code-success = "Single Code Success"
  }



  ####################################################################################
  ###                         Structure based detections                           ###
  ####################################################################################

  ####################################################################################
  # Usage detections                                                                 #
  #                                                                                  #
  #    There are 5 types of detections:                                              #
  #       * RUsage: Raised when an element with R usage is not populated             #
  #       * XUsage: Raised when an element with X  usage is populated                #
  #       * WUsage: Raised when an element with W  usage is populated                #
  #       * REUsage: Raised when an element with RE usage is not populated           #
  #       * OUsage: Raised when an element with O usage is populated                 #
  #                                                                                  #
  #    The template takes one parameter:                                             #
  #        the location formatted as:  ElementType ElementPath (ElementDescription)  #
  ####################################################################################

  r-usage {
    template = "The required %s is missing"
    category = ${report.category.usage}
    classification = ${report.classification.error}
  }

  x-usage {
    template = "The %s is present whereas it is an unsupported element (Usage = X)"
    category = ${report.category.usage}
    classification = ${report.classification.error}
  }

  w-usage {
    template = "The %s is present whereas it is a withdrawn element (Usage = W)"
    category = ${report.category.usage}
    classification = ${report.classification.error}
  }

  re-usage {
    template = "%s is missing. Depending on the use case and data availability it may be appropriate to value this element (Usage is "RE", Required, but may be Empty)."
    category = ${report.category.usage}
    classification = ${report.classification.warning}
  }

  o-usage {
    template = "Optional element %s was populated with the value %s."
    category = ${report.category.o-usage}
    classification = ${report.classification.informational}
  }

  o-usage-complex {
    template = "Optional element %s was populated."
    category = ${report.category.o-usage}
    classification = ${report.classification.informational}
  }

  predicate-usage-selection {
    template = "Usage %s was selected for %s with conditional usage C(%s/%s) and predicate '%s'. Condition evaluated to '%s'"
    category = ${report.category.predicate-usage-selection}
    classification = ${report.classification.note}
  }

  dynamic-mapping-match {
    template = "%s was mapped dynamically to datatype '%s' based on reference values %s"
    category = ${report.category.dynamic-mapping-match}
    classification = ${report.classification.note}
  }

  #######################################################################################
  #   Cardinality detection                                                             #
  #                                                                                     #
  #   The cardinality detection is issued when the number of repetitions of an          #
  #   element is not in the specified cardinality range.                                #
  #                                                                                     #
  #   The template takes four parameters:                                               #
  #     $1 is the location formatted as: ElementType ElementPath (Element Description)  #
  #     $2 is the minimum cardinality                                                   #
  #     $3 is the maximum cardinality                                                   #
  #     $4 is the number of repetitions found                                           #
  #######################################################################################

  cardinality {
    template = "%s must be in the cardinality range of [%s, %s]; %s occurrences found"
    category = ${report.category.cardinality}
    classification = ${report.classification.error}
  }

  #############################################################################################
  #   Null Cardinality detection                                                              #
  #                                                                                           #
  #   The null cardinality detection is issued when a null field has more than one instance.  #
  #############################################################################################

  null-cardinality {
    template = "%s has a null value and more than one occurrence; %s occurrences found"
    category = ${report.category.cardinality}
    classification = ${report.classification.error}
  }

  #############################################################################################
  #    Constant Value detection                                                               #
  #                                                                                           #
  #    The constant value detection is issued when value of a primitive element               #
  #    is not in equal to the constant value defined in the profile                           #
  #                                                                                           #
  #    The template takes four parameters:                                                    #
  #      $1 is the location formatted as: ElementType ElementPath (Element Description)       #
  #      $2 expected constant value                                                           #
  #      $3 found constant value                                                              #
  #      $4 the value of the element                                                          #
  #############################################################################################

  constant-value {
    template = "The value of %s must be '%s' but '%s' was found"
    category = ${report.category.constant-value}
    classification = ${report.classification.error}
  }

  constant-value-spec-error {
    template = "%s has a constant value definition of '%s' but is a complex data element"
    category = ${report.category.constant-value-spec-error}
    classification = ${report.classification.spec-error}
  }

  #############################################################################################
  #    Length detection                                                                       #
  #                                                                                           #
  #    The length detection is issued when the length of a primitive element                  #
  #    is not in the specified length range.                                                  #
  #                                                                                           #
  #    The template takes four parameters:                                                    #
  #      $1 is the location formatted as: ElementType ElementPath (Element Description)       #
  #      $2 is the minimum length                                                             #
  #      $3 is the maximum length                                                             #
  #      $4 the value of the element                                                          #
  #############################################################################################

  length {
    template = "The length of %s must be within the range [%s, %s]. Value = '%s'"
    category = ${report.category.length}
    classification = ${report.classification.warning}
  }

  length-spec-error-no-valid {
    template = "No valid length specification was found for element %s"
    category = ${report.category.length-spec-error}
    classification = ${report.classification.spec-error}
  }

  length-spec-error-xor {
    template = "Length specification error for element %s. One of (MaxLength, MinLength) or ConfLength should be present, but not both"
    category = ${report.category.length-spec-error}
    classification = ${report.classification.spec-error}
  }

  ##################################################################################
  #    Format detection                                                            #
  #                                                                                #
  #    The format detection is issued when the value of a primitive element        #
  #    is not valid according to the format defined or derived from the data type. #
  #                                                                                #
  #    The template takes one parameters: The error message                        #
  ##################################################################################

  format {
    template = "%s"
    category = ${report.category.format}
    classification = ${report.classification.error}
  }

  ####################################################################################
  #    Extra children detection                                                      #
  #                                                                                  #
  #    This detection is issued when a complex element has extra children            #
  #                                                                                  #
  #    The template takes one parameter:                                             #
  #       the location formatted as: ElementType ElementPath (Element Description)   #
  ####################################################################################

  extra {
    template = "%s has extra children"
    category = ${report.category.extra}
    classification = ${report.classification.error}
  }

  ########################################################################################
  #    Unescaped Sep detection                                                           #
  #                                                                                      #
  #    This detection is issued when a primitive element contains unescaped separators   #
  #                                                                                      #
  #    The template takes one parameter:                                                 #
  #       the location formatted as: ElementType ElementPath (Element Description)       #
  ########################################################################################

  unescaped {
    template = "The primitive %s contains at least one unescaped delimiter"
    category = ${report.category.unescaped}
    classification = ${report.classification.error}
  }

  ############################################################################################
  #    Unexpected Segment detection                                                          #
  #                                                                                          #
  #    This detection is issued when an unexpected segment is found at a specific position   #
  #                                                                                          #
  #    The template takes one parameter: the content representing the segment                #
  ############################################################################################

  unexpected {
    template = "Segment %s is not expected at this location"
    category = ${report.category.unexpected}
    classification = ${report.classification.error}
  }

  #################################################################################
  #   Invalid Segment definition detection                                        #
  #                                                                               #
  #   This detection is issued when an invalid content is found in the message    #
  #                                                                               #
  #   The template takes one parameter: the content representing the segment      #
  #################################################################################

  invalid {
    template = "'%s' is not a valid segment definition"
    category = ${report.category.invalid}
    classification = ${report.classification.error}
  }

  ############################################################################################################
  #    Unresolved dynamic mapping definition detection                                                       #
  #                                                                                                          #
  #    This detection is issued when a the reference values are not found in dynamic mapping                 #
  #	   for varies fields                                                                                     #
  #                                                                                                          #
  #    The template takes 3 parameters : 1- First reference value, 2- Second reference value, 3- Element     #
  ############################################################################################################

  unresolved-field {
  	template = "The values ('%s','%s') were not found in Dynamic Mapping for %s"
    category = ${report.category.unresolved-field}
    classification = ${report.classification.error}
  }

  ##########################################################################################################
  ###                                       Content based detections                                     ###
  ##########################################################################################################

  ##########################################################################################################
  #    This detection is issued for a failed constraint verification                                       #
  #                                                                                                        #
  #    The template takes two parameter:                                                                   #
  #       $1 The id of the constraint                                                                      #
  #       $2 The description of the constraint                                                             #
  ##########################################################################################################

  coconstraint-failure {
    template = "If %s then %s %s"
    category = ${report.category.coconstraint-failure}
    classification = ${report.classification.error}
  }

  coconstraint-success {
    template = "If %s then %s"
    category = ${report.category.coconstraint-success}
    classification = ${report.classification.affirmative}
  }

  highlevel-content {
    	category = "High-level Content Error"
    	classification = ${report.classification.error}
  }

  constraint-failure {
    template = "%s - %s"
    category = ${report.category.constraint-failure}
    classification = ${report.classification.error}
    strength {
       shall = ${report.classification.error}
       should = ${report.classification.warning}
    }
  }

  constraint-success {
    template = "%s - %s"
    category = ${report.category.constraint-success}
    classification = ${report.classification.affirmative}
  }

  constraint-spec-error {
    template = "%s - %s"
    category = ${report.category.constraint-spec-error}
    classification = ${report.classification.spec-error}
  }

  content-failure {
    template = "%s - %s"
    category = ${report.category.content-failure}
    classification = ${report.classification.error}
    strength {
       shall = ${report.classification.error}
       should = ${report.classification.warning}
    }
  }

  content-success {
    template = "%s - %s"
    category = ${report.category.content-success}
    classification = ${report.classification.affirmative}
  }

  content-spec-error {
    template = "%s - %s"
    category = ${report.category.content-spec-error}
    classification = ${report.classification.spec-error}
  }

  ################################################################################
  #    This detection is issued for a successful predicate verification          #
  #                                                                              #
  #    The template takes one parameter: the predicate as string                 #
  ################################################################################

  predicate-success {
    template = "%s"
    category = ${report.category.predicate-success}
    classification = ${report.classification.affirmative}
  }

  ##################################################################################
  #    This detection is issued for a failed predicate verification                #
  #                                                                                #
  #    The template takes three parameter:                                         #
  #       $1 The formatted string representing the usage error                     #
  #       $2 The usage to be used based on the condition                           #
  #       $3 The predicate description                                             #
  ##################################################################################

  predicate-failure {
    template = "%s. The element is %s based on the condition predicate evaluation: %s"
    category = ${report.category.predicate-failure}
    classification = ${report.classification.error}
  }

  ################################################################################
  #    This detection is issued for a problematic predicate verification         #
  #                                                                              #
  #    The template takes one parameter: the predicate as string                 #
  ################################################################################

  predicate-spec-error {
    template = "%s"
    category = ${report.category.predicate-spec-error}
    classification = ${report.classification.spec-error}
  }

  ##################################################################################################
  ###                                   Value set based detections                               ###
  ##################################################################################################

  ############################################################################################
  #    NoUsage                                                                               #
  #                                                                                          #
  #    This detection is raised when the code is in the value set but has no usage defined   #
  #                                                                                          #
  #    The template takes four parameters:                                                   #
  #       $1 The value of the data element                                                   #
  #       $2 The location formatted as: ElementType ElementPath (Element Description)        #
  #       $3 The id of the value set                                                         #
  #       $4 If matched from code pattern - The pattern it matched " code (regex) "          #
  ############################################################################################

  no-code-usage {
    template = "The value '%s' at location %s has no code usage in Value Set: %s%s"
    category = ${report.category.no-code-usage}
    classification = ${report.classification.alert}
  }

  ############################################################################################
  #    EVS                                                                                   #
  #                                                                                          #
  #    This detection is raised when the code is in the value set but the usage is E         #
  #                                                                                          #
  #    The template takes three parameters:                                                  #
  #       $1 The value of the data element                                                   #
  #       $2 The location formatted as: ElementType ElementPath (Element Description)        #
  #       $3 The id of the value set                                                         #
  #       $4 If matched from code pattern - The pattern it matched " code (regex) "          #
  ############################################################################################

  evs {
    template = "The value '%s' at location %s is an excluded (E) code; Value Set: %s%s"
    category = ${report.category.evs}
    classification = ${report.classification.error}
    overrides {

      suggested {
        default {
          classification = ${report.classification.alert}
        }
      }

      undetermined {
        default {
          classification = ${report.classification.alert}
        }
      }

    }
  }

  ############################################################################################
  #    PVS                                                                                   #
  #                                                                                          #
  #    This detection is raised when the code is in the value set but the usage is P         #
  #                                                                                          #
  #    The template takes three parameters:                                                  #
  #       $1 The value of the data element                                                   #
  #       $2 The location formatted as: ElementType ElementPath (Element Description)        #
  #       $3 The id of the value set                                                         #
  #       $4 If matched from code pattern - The pattern it matched " code (regex) "          #
  ############################################################################################

  pvs {
    template = "The value '%s' at location %s is a permitted (P) code; Value Set: %s%s"
    category = ${report.category.pvs}
    classification = ${report.classification.alert}
  }

  ############################################################################################
  #    RVS                                                                                   #
  #                                                                                          #
  #    This detection is raised when the code is in the value set but the usage is R         #
  #                                                                                          #
  #    The template takes three parameters:                                                  #
  #       $1 The value of the data element                                                   #
  #       $2 The location formatted as: ElementType ElementPath (Element Description)        #
  #       $3 The id of the value set                                                         #
  ############################################################################################

  rvs {
    template = "The value '%s' at location %s is a required (R) code; Value Set: %s%s"
    category = ${report.category.rvs}
    classification = ${report.classification.affirmative}
    overrides {

      suggested {
        default {
          classification = ${report.classification.alert}
        }
      }

      undetermined {
        default {
          classification = ${report.classification.alert}
        }
      }

    }
  }

  ############################################################################################
  #    Legacy 0396                                                                           #
  #                                                                                          #
  #    This detection is raised when a value set in the value set library                    #
  #    matches the name .*0396.* and contains either HL7nnnn or 99zzz without                #
  #    the CodePattern attribute and feature flag legacy0396 is active                       #
  #                                                                                          #
  #    The template takes no parameter                                                       #
  #                                                                                          #
  ############################################################################################

  legacy-0396 {
    template = "The value set library contains value sets matching the name .*0396.* and containing the value ['HL7nnnn' | '99zzz'] defined as a code, instead of a pattern. To maintain compatibility with legacy profiles, those codes will be interpreted as patterns. It is highly recommended to modify the profile to define them as patterns instead of codes. For example,  for the pattern 'HL7nnnn' add the CodePattern=\"HL7[0-9]{4}\" to the value set  or alternatively explicitly replace the value HL7nnnn with the supported HL7 table names e.g., HL70001, HL70005, etc."
    category = ${report.category.vs-0396}
    classification = ${report.classification.note}
  }

  ############################################################################################
  #    UBS                                                                                   #
  #                                                                                          #
  #    This detection is raised when a binding has U binding strength                        #
  #                                                                                          #
  #    The template takes three parameters:                                                  #
  #       $1 The value sets of the binding                                                   #
  #       $2 The location formatted as: ElementType ElementPath (Element Description)        #
  ############################################################################################

  ubs {
    template = "A binding with value sets %s at location '%s' has Undetermined binding strength"
    category = ${report.category.ubs}
    classification = ${report.classification.alert}
  }

  ############################################################################################
  #    Duplicate Code                                                                        #
  #                                                                                          #
  #    This detection is raised when the code is found multiple times in ValueSet            #
  #                                                                                          #
  #    The template takes three parameters:                                                  #
  #       $1 The value of the data element                                                   #
  #       $2 The location formatted as: ElementType ElementPath (Element Description)        #
  #       $3 The id of the value sets                                                        #
  ############################################################################################

  duplicate-code {
    template = "Multiple occurrences of the value '%s' at location %s where found in Value Sets: %s"
    category = ${report.category.duplicate-code}
    classification = ${report.classification.spec-error}
  }

  ############################################################################################
  #    Duplicate Code & Code System                                                          #
  #                                                                                          #
  #    This detection is raised when the code is found multiple times in ValueSet            #
  #                                                                                          #
  #    The template takes three parameters:                                                  #
  #       $1 The value of the data element                                                   #
  #       $2 The value of code system                                                        #
  #       $3 The location formatted as: ElementType ElementPath (Element Description)        #
  #       $4 The id of the value sets                                                        #
  ############################################################################################

  duplicate-code-codesystem {
    template = "Multiple occurences of the code '%s' and code system %s at location %s where found in Value Sets: %s"
    category = ${report.category.duplicate-code}
    classification = ${report.classification.spec-error}
  }

  ############################################################################################
  #    Multiple ValueSets on Simple Element                                                  #
  #                                                                                          #
  #    This detection is raised a binding with multiple value sets is defined on a simple    #
  #    element                                                                               #
  #                                                                                          #
  #    The template takes 2 parameters:                                                      #
  #       $1 The value sets                                                                  #
  #       $2 The location formatted as: ElementType ElementPath (Element Description)        #
  ############################################################################################

  multi-vs-simple {
    template = "A binding with multiple value sets %s was defined for primitive element at location '%s'"
    category = ${report.category.vs-spec-error}
    classification = ${report.classification.spec-error}
  }


  ##########################################################################################
  #    Code Not Found                                                                      #
  #                                                                                        #
  #    This detection is raised when the code cannot be found in the value set             #
  #                                                                                        #
  #    The template takes three parameters:                                                #
  #       $1 The value of the data element                                                 #
  #       $2 The location formatted as: ElementType ElementPath (Element Description)      #
  #       $3 The id of the value set                                                       #
  ##########################################################################################
  code-not-found-simple {
    template = "The value '%s' at location %s is not member of the value set %s"
    category = ${report.category.code-not-found}
    classification = ${report.classification.alert}
    overrides {
      required {
        default  {
           classification = ${report.classification.error}
        }	  
        open {
          default  {
            template = "The value '%s' at location %s is not member of the value set %s. The value set is an open value set. Validation can only be performed against a snapshot of an open value set. The snapshot may be different from the current version of the value set."
          }
        }
        closed {
          dynamic {
            template = "The value '%s' at location %s is not member of the value set %s. The value set is a dynamic value set. Validation can only be performed against a snapshot of a dynamic value set. The snapshot may be different from the current version of the value set."
          }
        }
        no-value {
          dynamic {
            template = "The value '%s' at location %s is not member of the value set %s. The value set is a dynamic value set. Validation can only be performed against a snapshot of a dynamic value set. The snapshot may be different from the current version of the value set."
          }
        }
      }
    }
  }

  code-not-found-coded-element {
    template = "The code '%s' and code system '%s' at location %s is not member of the value set %s"
    category = ${report.category.code-not-found}
    classification = ${report.classification.alert}
    overrides {
      required {
        default  {
           classification = ${report.classification.error}
        }	  
        open {
          default  {
            template = "The code '%s' and code system '%s' at location %s is not member of the value set %s. The binding contains an open value set. Validation can only be performed against a snapshot of an open value set. The snapshot may be different from the current version of the value set."
          }
        }
        closed {
          dynamic {
            template = "The code '%s' and code system '%s' at location %s is not member of the value set %s. The binding contains a dynamic value set. Validation can only be performed against a snapshot of a dynamic value set. The snapshot may be different from the current version of the value set."
          }
        }
        no-value {
          dynamic {
            template = "The code '%s' and code system '%s' at location %s is not member of the value set %s. The binding contains a dynamic value set. Validation can only be performed against a snapshot of a dynamic value set. The snapshot may be different from the current version of the value set."
          }
        }
      }
    }
  }
  
  code-not-found-cs {
    template = "The value ('%s', '%s') at location %s is not member of the value set %s, expected code system '%s'"
    category = ${report.category.code-not-found}
    classification = ${report.classification.alert}
    overrides {
      required {
        default  {
           classification = ${report.classification.error}
        }	  
        open {
          default  {
            template = "The value ('%s', '%s') at location %s is not member of the value set %s, expected code system '%s'. The binding contains an open value set. Validation can only be performed against a snapshot of an open value set. The snapshot may be different from the current version of the value set."
          }
        }
        closed {
          dynamic {
            template = "The value ('%s', '%s') at location %s is not member of the value set %s, expected code system '%s'. The binding contains a dynamic value set. Validation can only be performed against a snapshot of a dynamic value set. The snapshot may be different from the current version of the value set."
          }
        }
        no-value {
          dynamic {
            template = "The value ('%s', '%s') at location %s is not member of the value set %s, expected code system '%s'. The binding contains a dynamic value set. Validation can only be performed against a snapshot of a dynamic value set. The snapshot may be different from the current version of the value set."
          }
        }
      }
    }
  }

  code-not-found-cs-empty {
    template = "The value '%s' at location %s was found in the value set %s associated with code system '%s', but code system was not populated in the message at location %s. The validation engine can not determine if the expected code was used."
    category = ${report.category.code-not-found}
    classification = ${report.classification.error}
  }

  #######################################################################################
  #    Value Set Not Found                                                              #
  #                                                                                     #
  #    This detection is raised when the value set cannot be found in the library       #
  #                                                                                     #
  #    The template takes three parameters:                                             #
  #       $1 The value of the data element                                              #
  #       $2 The location formatted as: ElementType ElementPath (Element Description)   #
  #       $3 The id of the value set                                                    #
  #######################################################################################
  vs-not-found {
    template = "The value '%s' at location %s cannot be evaluated. The value set '%s' cannot be found."
    category = ${report.category.vs-not-found}
    classification = ${report.classification.spec-error}
  }

  vs-not-found-binding {
    template = "The value set '%s' specified for binding at location %s cannot be found."
    category = ${report.category.vs-not-found}
    classification = ${report.classification.spec-error}
  }

  ################################################################################
  #    Empty Value Set                                                           #
  #                                                                              #
  #    This detection is raised when the value set is empty                      #
  #                                                                              #
  #    The template takes one parameter: The id of the value set                 #
  ################################################################################
  empty-vs {
    template = "The value set %s is empty"
    category = ${report.category.empty-vs}
    classification = ${report.classification.alert}
  }

  #########################################################################################
  #   Dynamic VS                                                                          #
  #                                                                                       #
  #   This detection is raised when the value set is classified as dynamic for stability  #
  #   Only triggered with code not found or PVS                                           #
  #                                                                                       #
  #   The template takes two parameters:                                                  #
  #       $1 The value set id                                                             #
  #       $2 The location formatted as: ElementType ElementPath (Element Description)     #
  #########################################################################################
  dynamic-vs {
    template = "The value set %s bound at location %s has as dynamic stability. Validation can only be performed against a snapshot of a dynamic value set. The snapshot may be different from the current version of the value set."
    category = ${report.category.dynamic-vs}
    classification = ${report.classification.alert}
  }

  ################################################################################
  #   VS Error                                                                   #
  #                                                                              #
  #   This detection is raised when there is an error in the value set           #
  #                                                                              #
  #   The template takes one parameter: The error message                        #
  ################################################################################
  vs-error {
    template = "%s"
    category = ${report.category.vs-error}
    classification = ${report.classification.spec-error}
  }

  ##############################################################################################
  #   Binding Location                                                                         #
  #                                                                                            #
  #   This detection is raised when there is an error while resolving the binding location     #
  #                                                                                            #
  #   The template takes one parameter: The error message                                      #
  ##############################################################################################
  binding-location {
    template = "%s"
    category = ${report.category.binding-location}
    classification = ${report.classification.spec-error}
  }

  ###################################################################################
  #   VS No Validation                                                              #
  #                                                                                 #
  #   This detection is raised when the value set is excluded from the validation   #
  #                                                                                 #
  #   The template takes one parameter: The id of the value set                     #
  ###################################################################################
  vs-no-validation {
    template = "The value set %s has been excluded from the validation"
    category = ${report.category.vs-no-validation}
    classification = ${report.classification.note}
  }

  ############################################################################################
  #   Usage and Extensibility Not Compatible                                                 #
  #                                                                                          #
  #   This detection is raised when value set is closed and code is “P”                      #
  #                                                                                          #
  #       $1 The value of the data element                                                   #
  #       $2 The location formatted as: ElementType ElementPath (Element Description)        #
  #       $3 The id of the value set                                                         #
  ############################################################################################
  usage-and-extensibility {
    template = "The value '%s' at location %s is a permitted (P) code in the Closed Value Set: %s"
    category = ${report.category.vs-error}
    classification = ${report.classification.alert}
  }

  ####################################################################################
  #    Coded Element                                                                 #
  #                                                                                  #
  #    This detection is raised when coded element validation fails                  #
  #                                                                                  #
  #    The template takes one parameter: The error message describing the problem    #
  ####################################################################################

  coded-element {
    template = "%s"
    category = ${report.category.coded-element}
    classification = ${report.classification.alert}
    overrides {
      required {
        default  {
           classification = ${report.classification.error}
        }	  
        open {
          default  {
            template = "The code '%s' and code system '%s' at location %s is not member of the value set %s. The binding contains an open value set. Validation can only be performed against a snapshot of an open value set. The snapshot may be different from the current version of the value set."
          }
        }
        closed {
          dynamic {
            template = "The code '%s' and code system '%s' at location %s is not member of the value set %s. The binding contains a dynamic value set. Validation can only be performed against a snapshot of a dynamic value set. The snapshot may be different from the current version of the value set."
          }
        }
        no-value {
          dynamic {
            template = "The code '%s' and code system '%s' at location %s is not member of the value set %s. The binding contains a dynamic value set. Validation can only be performed against a snapshot of a dynamic value set. The snapshot may be different from the current version of the value set."
          }
        }
      }
    }
  }
  
  #####################################################################################
  #    Coded Element XOR                                                              #
  #                                                                                   #
  #    This detection is raised when coded element validation fails                   #
  #                                                                                   #
  #    The template takes one parameter: The error message describing the problem     #
  #####################################################################################
  coded-element-xor {
    template = "Elements %s are all valued from the same value set %s"
    category = ${report.category.coded-element-xor}
    classification = ${report.classification.error}
    overrides {
	  undetermined {
        default  {
          classification = ${report.classification.alert}
        }
      }
      suggested {
        default  {
          classification = ${report.classification.alert}
        }
      }
    }
  }

  ##################################################################################################
  ###                                    Single Code                                             ###
  ##################################################################################################


  #####################################################################################
  #    Single Code XOR
  #
  #    This detection is raised when a single code bound to a coded element at multiple possible location is found in more than one location
  #
  #    The template takes:
  #     1) Expected Code
  #     2) Expected Code System
  #     3) Locations Found
  #     4) Coded Element path
  #####################################################################################
  single-code-xor {
    template = "Code '%s' from code system '%s' was found at multiple locations %s within the coded element %s. Code must be used at only one location."
    category = ${report.category.single-code-failure}
    classification = ${report.classification.error}
  }

  #####################################################################################
  #    Single Code Invalid Code System
  #
  #    This detection is raised when a single code bound to a coded element matches the code but not the code system
  #
  #    The template takes:
  #     1) Expected Code
  #     2) Expected Code System
  #     3) Location where Code Match Found
  #     4) Found Code System
  #     5) Code System Location
  #     6) Expected Code System
  #####################################################################################
  single-code-cs-invalid {
    template = "Code '%s' from code system '%s' was not found in location %s; Code System Value '%s' found at %s doesn't match expected '%s'"
    category = ${report.category.single-code-failure}
    classification = ${report.classification.error}
  }

  #####################################################################################
  #    Single Code Code System Not Found
  #
  #    This detection is raised when a single code bound to a coded element matches the code but the code system is not populated
  #
  #    The template takes:
  #     1) Expected Code
  #     2) Expected Code System
  #     3) Location where Code Match Found
  #     4) Location where Code System was expected
  #####################################################################################
  single-code-cs-not-found {
    template = "Code '%s' from code system '%s' was not found in location %s; Code System expected but was not populated at location %s"
    category = ${report.category.single-code-failure}
    classification = ${report.classification.error}
  }

  #####################################################################################
  #    Single Code Not Found
  #
  #    This detection is raised when a single code bound to a location was not found
  #
  #    The template takes:
  #     1) Expected Code
  #     2) Expected Code System
  #     3) Found Code
  #     4) Found Code Location
  #     5) Expected Code
  #####################################################################################
  single-code-not-found {
    template = "Code '%s' from code system '%s' was not found; Code Value '%s' found at %s doesn't match expected '%s'"
    category = ${report.category.single-code-failure}
    classification = ${report.classification.error}
  }

  #####################################################################################
  #    Single Code Success
  #
  #    This detection is raised when a single code requirement was satisfied
  #
  #    The template takes:
  #     1) Expected Code
  #     2) Expected Code System
  #     4) Found Code Location
  #####################################################################################
  single-code-success {
    template = "Code '%s' from code system '%s' was found at %s"
    category = ${report.category.single-code-success}
    classification = ${report.classification.affirmative}
  }

  ##################################################################################################
  ###                                    Slicing based detections                                ###
  ##################################################################################################


  #####################################################################################
  #    Assertion Slicing Match
  #
  #    This detection is raised when a slice has been matched based on an assertion
  #
  #    The template takes:
  #     1) Assertion Description
  #     2) Target element for the slice
  #     3) Type of resource applied (e.g. Segment, Datatype)
  #     4) Name of applied resource
  #####################################################################################
  assertion-slicing-match {
    template = "A slice with condition '%s' was matched for element %s, %s %s is applied"
    category = ${report.category.slicing}
    classification = ${report.classification.note}
  }

  #####################################################################################
  #    Occurrence Slicing Match
  #
  #    This detection is raised when a slice has been matched based on occurrence number
  #
  #    The template takes:
  #     1) Occurrence number
  #     2) Target element for the slice
  #     3) Type of resource applied (e.g. Segment, Datatype)
  #     4) Name of applied resource
  #####################################################################################
  occurrence-slicing-match {
    template = "A slice for occurrence number %s was matched for element %s, %s %s is applied"
    category = ${report.category.slicing}
    classification = ${report.classification.note}
  }

  #####################################################################################
  #    No Matched Slice
  #
  #    This detection is raised when on element has slicing defined but no slice is matched
  #
  #    The template takes:
  #     1) Target element for the slicing
  #     2) Default Flavor Used
  #####################################################################################
  slicing-no-match {
    template = "Slicing was defined for element %s but not slice matched, default flavor used %s"
    category = ${report.category.slicing}
    classification = ${report.classification.note}
  }

  #####################################################################################
  #    Slicing Assertion Inconclusive
  #
  #    This detection is raised when the evaluation of a slice condition is inconclusive
  #
  #    The template takes:
  #     1) Condition Assertion Description
  #     2) Type of resource to be applied (e.g. Segment, Datatype)
  #     3) Name of resource to be applied
  #     4) Target element for the slicing
  #     5) Reason why it's inconclusive
  #####################################################################################
  assertion-slicing-inconclusive {
      template = "Slice with condition '%s' and target reference of %s %s could not be evaluated for element %s, due to : %s"
      category = ${report.category.slicing-spec-error}
      classification = ${report.classification.spec-error}
  }

  #####################################################################################
  #   Slicing Target Is Group
  #
  #    This detection is raised when the target of slicing is a group
  #
  #    The template takes:
  #     1) Target element for the slicing
  #####################################################################################
  slicing-target-group {
    template = "Segment slicing was defined for element %s, the target of segment slicing should be a segment"
    category = ${report.category.slicing-spec-error}
    classification = ${report.classification.spec-error}
  }

  #####################################################################################
  #   Slicing Match Error
  #
  #    This detection is raised when the slice match application results in an error
  #
  #    The template takes:
  #     1) Type of resource to be applied (e.g. Segment, Datatype)
  #     2) Name of resource to be applied
  #     3) Target element for the slicing
  #     4) Reason for error
  #####################################################################################
  slicing-match-error {
    template = "Slice with target reference of %s %s matched for element %s could not be applied due to : %s"
    category = ${report.category.slicing-spec-error}
    classification = ${report.classification.spec-error}
  }


  #####################################################################################
  #    Required Co-Constraint                                                         #
  #                                                                                   #
  #    This detection is raised when a required co-constraint is not satisfied        #
  #                                                                                   #
  #    The template takes:
  #     1) Group Instance Description (Optional)
  #     2) Co-Constraint Description (Required)
  #####################################################################################

  required-co-constraint {
    template = "%sThe co-constraint defined as %s is required but was not found"
    category = ${report.category.co-constraint}
    classification = ${report.classification.error}
  }

  #####################################################################################
  #    Required Group                                                                 #
  #                                                                                   #
  #    This detection is raised when a required co-constraint group is not found      #
  #                                                                                   #
  #    The template takes:
  #     1) Group Name
  #     2) Primary Co-Constraint Description
  #####################################################################################

  required-group {
    template = "The co-constraint group '%s' is required but was not found. REASON : the primary co-constraint of %s defined as: %s, was not found. Secondary co-constraints of a group are not evaluated when the primary co-constraint is not found in the message."
    category = ${report.category.co-constraint}
    classification = ${report.classification.error}
  }


  #####################################################################################
  #    Cardinality Co-Constraint                                                      #
  #                                                                                   #
  #    The template takes:
  #     1) Group Instance Description (Optional)
  #     2) Co-Constraint Description (Required)
  #     3) Range
  #     4) Number of occurrences
  #####################################################################################

  cardinality-co-constraint {
    template = "%sThe co-constraint defined as %s, must be in the cardinality range of [%s, %s] but %s occurrences found"
    category = ${report.category.co-constraint}
    classification = ${report.classification.error}
  }

  #####################################################################################
  #    Cardinality Group                                                              #
  #                                                                                   #
  #    The template takes:
  #     1) Group Name
  #     2) Range
  #     3) Number of occurrences
  #     4) Grouper
  #     5) Grouper Values
  #####################################################################################

  cardinality-group {
    template = "The co-constraint group '%s' must be in the cardinality range of [%s, %s] but %s occurrences found. Co-constraint group occurrences are identified by %s valued %s"
    category = ${report.category.co-constraint}
    classification = ${report.classification.error}
  }

  # PlainText Failure, when a plaintext co-constraint cell evaluation fails
  # 1) Group Instance Description (Optional)
  # 2) Co-Constraint Description (Required)
  # 3) CoConstraint Cell (PlainText) description
  # 4) Value found
  cc-plain-text-failure {
    template = "%sThe co-constraint defined as %s failed to satisfy the constraint requirement: %s. REASON : Value '%s' was found."
    category = ${report.category.co-constraint}
    classification = ${report.classification.error}
  }

  # Code Failure, when a code co-constraint cell evaluation fails because the code was not found
  # When locations are populated but code value does not match
  # 1) Group Instance Description (Optional)
  # 2) Co-Constraint Description (Required)
  # 3) CoConstraint Cell (Code) description
  # 4) Code Found
  # 5) Code Expected
  cc-code-failure {
    template = "%sThe co-constraint defined as %s failed to satisfy the constraint requirement: %s. REASON: Invalid code '%s'; '%s' was expected."
    category = ${report.category.co-constraint}
    classification = ${report.classification.error}
  }

  # Code Failure, when a code co-constraint cell evaluation fails because the code system was invalid
  # When code was found with a different code system
  # 1) Group Instance Description (Optional)
  # 2) Co-Constraint Description (Required)
  # 3) CoConstraint Cell (Code) description
  # 4) Code System Found
  # 5) Code System Expected
  cc-code-failure-invalid-codesys {
    template = "%sThe co-constraint defined as %s failed to satisfy the constraint requirement: %s. REASON: Invalid code system '%s' found; '%s' was expected."
    category = ${report.category.co-constraint}
    classification = ${report.classification.error}
  }

  # Code Failure, when a code co-constraint cell evaluation fails because the code system was not populated
  # When code was found but code system not populated
  # 1) Group Instance Description (Optional)
  # 2) Co-Constraint Description (Required)
  # 3) CoConstraint Cell (Code) description
  # 4) Code System Location
  cc-code-failure-notfound-codesys {
    template = "%sThe co-constraint defined as %s failed to satisfy the constraint requirement: %s. REASON: Code system not populated at location %s"
    category = ${report.category.co-constraint}
    classification = ${report.classification.error}
  }

  # ValueSet Failure, when a value set co-constraint cell evaluation fails
  # When the codes at binding locations were not found in any ValueSet
  # 1) Group Instance Description (Optional)
  # 2) Co-Constraint Description (Required)
  # 3) CoConstraint ValueSet Binding description
  cc-vs-failure {
    template = "%sThe co-constraint defined as %s failed to satisfy the constraint requirement: %s."
    category = ${report.category.co-constraint}
    classification = ${report.classification.error}
  }

  # Co-Constraint Cell Success
  # 1) Group Instance Description (Optional)
  # 2) Co-Constraint Description (Required)
  # 3) CoConstraint Cell description
  cc-success {
    template = "%sThe co-constraint defined as %s satisfied constraint : %s"
    category = ${report.category.co-constraint}
    classification = ${report.classification.affirmative}
  }

  # Specification error, when a co-constraint cell evaluation could not be done
  # because of an issue related to the specification (e.g invalid path)
  # 1) CoConstraint Cell description
  # 2) Location where it was evaluated from
  # 3) Reason why it could not be conclusive
  cc-spec-error {
    template = "Evaluation of '%s' from context location %s was inconclusive due to error : %s"
    category = ${report.category.co-constraint-spec-error}
    classification = ${report.classification.spec-error}
  }

  # Specification error, when a value set co-constraint cell evaluation could not be done
  # because of an issue related to the specification of the binding
  # 1) CoConstraint Cell (Value Set) description
  # 2) Location where it was evaluated from
  cc-binding-spec-error {
    template = "Evaluation of '%s' from context location %s was inconclusive"
    category = ${report.category.co-constraint-spec-error}
    classification = ${report.classification.spec-error}
  }

  # Specification error, when a the evaluation of the condition of a conditional co-constraint table
  # could not be done because of an issue related to the specification
  # 1) Condition description
  cc-condition-spec-error {
    template = "CoConstraint table condition '%s' evaluation was inconclusive"
    category = ${report.category.co-constraint-spec-error}
    classification = ${report.classification.spec-error}
  }

  # Specification error, when co-constraint target segment can't be resolved
  # 1) Target path
  # 3) Reason
  cc-target-spec-error {
    template = "Co-Constraint binding's target segment at path %s evaluation was inconclusive due to : %s"
    category = ${report.category.co-constraint-spec-error}
    classification = ${report.classification.spec-error}
  }

  # Specification error, when co-constraint binding context can't be resolved
  # 1) Target path
  # 3) Reason
  cc-context-spec-error {
    template = "Co-Constraint binding's target context at path %s evaluation was inconclusive due to : %s"
    category = ${report.category.co-constraint-spec-error}
    classification = ${report.classification.spec-error}
  }

  # Specification error, when a the target of a co-constraint table is not a group or message
  # 1) Target path
  # 3) Specified target context
  # 4) Element at target path which is not a group or message
  cc-context-not-group-or-message {
    template = "Specified path %s for co-constraint on %s returned the element %s which is not a group or message"
    category = ${report.category.co-constraint-spec-error}
    classification = ${report.classification.spec-error}
  }

  # Specification error, when a the target of a co-constraint table is not a segment
  # 1) Target path
  # 3) Specified target segment
  # 4) Element at target path which is not a segment
  cc-element-not-segment {
    template = "Specified path %s for co-constraint on %s returned the element %s which is not a segment"
    category = ${report.category.co-constraint-spec-error}
    classification = ${report.classification.spec-error}
  }

  # GroupId not distinct when an individual co-constraint doesn't have a unique ID
  # 1) CoConstraint description
  # 2) GroupId location
  # 3) GroupId value
  # 4) Context
  cc-grouper-not-distinct {
    template = "%s should have a distinct Id at location %s, value '%s' is not distinct within %s"
    category = ${report.category.co-constraint}
    classification = ${report.classification.error}
  }

  # Specification error, when groupId evaluation is inconclusive
  # 1) Target path
  # 3) Reason
  cc-grouper-spec-error {
    template = "Co-Constraint group ID at path %s evaluation was inconclusive due to : %s"
    category = ${report.category.co-constraint-spec-error}
    classification = ${report.classification.spec-error}
  }
}

co-constraint {
	# (1) Segment name, (2) Selectors
	description = "%s segment with the following condition requirements: %s"
  # connector of selectors
  connector = "and"

  group-instance = "In co-constraint group %s with %s valued as '%s' "

	plain-text {
    	# (1) Segment Path, (2) Expected Value
    	selector = "%s is valued %s (Case Sensitive)"
      # (1) Segment Path, (2) Expected Value
      constraint = "%s SHALL be valued %s (Case Sensitive)"
    }
    code {
      # (1) Locations, (2) Expected Code Value, (3) Expected Code System Value
      selector = "%s is valued '%s' from code system %s"
      # (1) Locations, (2) Expected Code Value, (3) Expected Code System Value
      constraint = "%s SHALL be valued %s from the code system '%s'"
    }
    value-set {
      # (1) Locations, (2) Value Set Bindings
    	selector = "%s is valued with a code from one of the value sets: %s"
      # (1) Locations, (2) Value Set Bindings
      constraint = "%s SHALL be valued with a code from one of the value sets: %s"
    }
}

context-based {
  value-test-case-fixed = "Invalid content (based on test case fixed data). The value '%s' at '%s' does not match the expected value '%s'."
  value-test-case-fixed-list = "Invalid content (based on test case fixed data). The value '%s' at '%s' does not match one of the expected values '%s'."
}
